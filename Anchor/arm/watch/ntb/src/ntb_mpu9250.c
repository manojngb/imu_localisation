// #include "ntb_mpu9250.h"


// void ntb_mpu_sendbytes( uint8_t *data, uint8_t len )
// {
//   I2C_SlaveAddressConfig( I2C2, MPU_ADDR );
//   I2C_AutoEndCmd( I2C2, ENABLE );
//   I2C_NumberOfBytesConfig( I2C2, len );
//   I2C_MasterRequestConfig( I2C2, I2C_Direction_Transmitter );
//   I2C_TransferHandling(I2C2, MPU_ADDR, len, I2C_AutoEnd_Mode, uint32_t StartStopMode)


// }
// /* This function issues a start condition and 
//  * transmits the slave address + R/W bit
//  * 
//  * Parameters:
//  *    I2Cx --> the I2C peripheral e.g. I2C1
//  *    address --> the 7 bit slave address
//  *    direction --> the tranmission direction can be:
//  *            I2C_Direction_Tranmitter for Master transmitter mode
//  *            I2C_Direction_Receiver for Master receiver
//  */
// void ntb_mpu_i2c_start(uint8_t address, uint8_t direction){
//   // wait until I2C1 is not busy anymore
//   while(I2C_GetFlagStatus(I2C2, I2C_FLAG_BUSY));
  
//   // Send I2C1 START condition 
//   I2C_GenerateSTART(I2C2, ENABLE);
    
//   // wait for I2C1 EV5 --> Slave has acknowledged start condition
//   while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_MODE_SELECT));
    
//   // Send slave Address for write 
//   I2C_Send7bitAddress(I2C2, address, direction);
    
//   /* wait for I2C1 EV6, check if 
//    * either Slave has acknowledged Master transmitter or
//    * Master receiver mode, depending on the transmission
//    * direction
//    */ 
//   if(direction == I2C_Direction_Transmitter){
//     while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
//   }
//   else if(direction == I2C_Direction_Receiver){
//     while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
//   }
// }

// /* This function transmits one byte to the slave device
//  * Parameters:
//  *    I2Cx --> the I2C peripheral e.g. I2C1 
//  *    data --> the data byte to be transmitted
//  */
// void ntb_mpu_i2c_write(uint8_t data)
// {
//   I2C_SendData(I2C2, data);
//   // wait for I2C1 EV8_2 --> byte has been transmitted
//   while(!I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
// }

// /* This function reads one byte from the slave device 
//  * and acknowledges the byte (requests another byte)
//  */
// uint8_t ntb_mpu_i2c_readack(){
//   // enable acknowledge of recieved data
//   I2C_AcknowledgeConfig(I2C2, ENABLE);
//   // wait until one byte has been received
//   while( !I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED) );
//   // read data from I2C data register and return data byte
//   uint8_t data = I2C_ReceiveData(I2C2);
//   return data;
// }

// /* This function reads one byte from the slave device
//  * and doesn't acknowledge the recieved data 
//  */
// uint8_t ntb_mpu_i2c_readnack(){
//   // disabe acknowledge of received data
//   // nack also generates stop condition after last byte received
//   // see reference manual for more info
//   I2C_AcknowledgeConfig(I2C2, DISABLE);
//   I2C_GenerateSTOP(I2C2, ENABLE);
//   // wait until one byte has been received
//   while( !I2C_CheckEvent(I2C2, I2C_EVENT_MASTER_BYTE_RECEIVED) );
//   // read data from I2C data register and return data byte
//   uint8_t data = I2C_ReceiveData(I2C2);
//   return data;
// }

// /* This funtion issues a stop condition and therefore
//  * releases the bus
//  */
// void ntb_mpu_i2c_stop(){
//   // Send I2C1 STOP Condition 
//   I2C_GenerateSTOP(I2C2, ENABLE);
// }

// void ntb_mpu_writereg(uint8_t reg, uint8_t *byte, int len)
// {
//   int b=0;

//   // [1] write address (STM library writes 1 for TX, 0 for RX)
//   ntb_mpu_i2c_start((MPU_ADDR<<1), I2C_Direction_Transmitter);

//   // [2] write reg
//   ntb_mpu_i2c_write(reg);

//   // [3] write data
//   for(b=0; b<len; b++)
//   {
//     ntb_mpu_i2c_write(byte[b]);
//   }

//   // [4] done!
//   ntb_mpu_i2c_stop();

// }

// void ntb_mpu_readreg(uint8_t reg, uint8_t *buf, int len)
// {
//   int b=0;

//   // [1] write address (STM library writes 1 for TX, 0 for RX)
//   ntb_mpu_i2c_start((MPU_ADDR<<1), I2C_Direction_Transmitter);

//   // [2] write reg
//   ntb_mpu_i2c_write(reg);

//   // [3] read data, each requiring repeated start signal 
//   ntb_mpu_i2c_repstart((MPU_ADDR<<1), I2C_Direction_Receiver);

//   // read with ACK all but final byte
//   for( b=0; b<(len-1); b++ )
//   {
//     buf[b] = ntb_mpu_i2c_readack();
//   }

//   // read final byte with NACK
//   buf[b] = ntb_mpu_i2c_readnack();

//   // [4] done! - stop auto-generated by NACK
// }

// /*
//  * Read all IMU data (9 values)
//  */
// void ntb_mpu_readall(acc3_t* a, gyr3_t* g, mag3_t* m)
// {
//   // read accelerometer

//   // read gyroscope

//   // read magnetometer
// }
